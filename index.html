<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ ¡åœ’è¿·å®®é€ƒè„« (éŸ³æ¨‚+å‹•ç‰©ç‰ˆ)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #87CEEB;
            user-select: none;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            text-shadow: 2px 2px 4px #000;
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(to bottom, rgba(0,0,0,0.3), transparent);
        }
        
        #input-debug {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            pointer-events: none;
            opacity: 0.8;
        }
        .key-row { display: flex; gap: 5px; }
        .key-icon {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #fff;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 8px;
            font-family: monospace;
            font-size: 20px;
            transition: all 0.1s;
        }
        .key-active {
            background: #e67e22;
            transform: scale(0.9);
            box-shadow: 0 0 10px #e67e22;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }
        #instructions {
            width: 500px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            text-align: center;
            color: #333;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 1px solid #ddd;
        }
        h1 { margin: 0 0 15px 0; color: #2c3e50; font-size: 36px; }
        p { font-size: 18px; margin: 8px 0; color: #555; }
        .key { background: #eee; color: #333; padding: 4px 10px; border: 1px solid #ccc; border-radius: 5px; font-weight: bold; }
        
        #start-btn {
            background: #2ecc71;
            color: white;
            font-size: 24px;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 5px 0 #27ae60;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        #start-btn:active {
            transform: translateY(4px);
            box-shadow: 0 1px 0 #27ae60;
        }

        #result-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            color: white;
            z-index: 20;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            pointer-events: auto;
        }
        button.retry-btn {
            padding: 15px 40px;
            font-size: 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }
        button.retry-btn:hover { background: #2980b9; transform: translateY(-2px); }
        .win-text { color: #2ecc71; font-size: 50px; text-shadow: 0 0 20px rgba(46, 204, 113, 0.5); font-weight: 800; }
        .lose-text { color: #e74c3c; font-size: 50px; text-shadow: 0 0 20px rgba(231, 76, 60, 0.5); font-weight: 800; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="hud">
            <div id="time-display">æ™‚é–“: 02:00</div>
            <div id="status">å°‹æ‰¾ç¶ è‰²å…‰æŸ±</div>
        </div>
        <div id="input-debug">
            <div class="key-row">
                <div id="key-w" class="key-icon">W</div>
            </div>
            <div class="key-row">
                <div id="key-a" class="key-icon">A</div>
                <div id="key-s" class="key-icon">S</div>
                <div id="key-d" class="key-icon">D</div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="blocker">
        <div id="instructions">
            <h1>æ ¡åœ’è¿·å®®é€ƒè„«</h1>
            <p>ğŸµ éŸ³æ¨‚è·‘é…·ç‰ˆ ğŸ‡</p>
            <hr style="margin: 15px 0;">
            <p><span class="key">W</span> å‰é€² &nbsp;&nbsp; <span class="key">S</span> å¾Œé€€</p>
            <p><span class="key">A</span> å·¦è½‰ &nbsp;&nbsp; <span class="key">D</span> å³è½‰</p>
            <br>
            <button id="start-btn">é–‹å§‹éŠæˆ²</button>
            <p style="font-size: 14px; margin-top: 15px; color: #e74c3c;">âš ï¸ è«‹ç¢ºèªè¼¸å…¥æ³•ç‚ºè‹±æ–‡</p>
        </div>
    </div>

    <div id="result-screen">
        <div id="result-message" class="win-text"></div>
        <p id="result-detail" style="font-size: 20px; margin-top: 10px;"></p>
        <button class="retry-btn" onclick="location.reload()">å†ç©ä¸€æ¬¡</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- éŸ³æ•ˆç®¡ç†å™¨ (Music & SFX) ---
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.nextStepTime = 0;
                this.bgmTimer = null;
                this.bgmNoteIndex = 0;
                this.isPlaying = false;
            }

            init() {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.startAmbience();
                this.startBGM();
                this.isPlaying = true;
            }

            stop() {
                this.isPlaying = false;
                if (this.bgmTimer) clearTimeout(this.bgmTimer);
                if (this.ctx) this.ctx.close();
            }

            // --- åˆæˆ BGM ---
            startBGM() {
                if (!this.ctx) return;
                
                // ç°¡å–®çš„è·‘é…·ç¯€å¥ (Bass + Lead)
                const bassLine = [110, 110, 146, 110, 130, 110, 98, 110]; // A2 scale
                const leadLine = [440, 0, 523, 440, 587, 0, 659, 587]; // A4 scale
                const tempo = 250; // ms per note

                const playStep = () => {
                    if (!this.isPlaying) return;

                    const now = this.ctx.currentTime;
                    const idx = this.bgmNoteIndex % 8;

                    // Bass (Square wave for retro feel)
                    if (bassLine[idx] > 0) {
                        this.playTone(bassLine[idx], 'sawtooth', 0.1, 0.05);
                    }

                    // Lead (Sine with delay effect simulation)
                    if (leadLine[idx] > 0 && Math.random() > 0.3) { // éš¨æ©Ÿå°‘å½ˆä¸€é»å¢åŠ è®ŠåŒ–
                        this.playTone(leadLine[idx], 'square', 0.1, 0.03);
                        setTimeout(() => this.playTone(leadLine[idx], 'sine', 0.1, 0.01), 150); // echo
                    }

                    // Hi-hat (White noise burst)
                    if (idx % 2 === 0) {
                        this.playNoise(0.03, 0.02);
                    }

                    this.bgmNoteIndex++;
                    this.bgmTimer = setTimeout(playStep, tempo);
                };

                playStep();
            }

            // --- SFX Utilities ---
            playTone(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playNoise(duration, vol) {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                
                // Highpass filter for hi-hat sound
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 5000;

                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            }

            // ç’°å¢ƒéŸ³ (é¢¨è²)
            startAmbience() {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * 2.0;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400; 

                const gain = this.ctx.createGain();
                gain.gain.value = 0.05;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            }

            playFootstep() {
                if (!this.ctx || this.ctx.currentTime < this.nextStepTime) return;
                // çŸ­ä¿ƒä½é »
                this.playTone(100, 'triangle', 0.05, 0.2);
                this.nextStepTime = this.ctx.currentTime + 0.35;
            }

            playCollision() {
                this.playTone(60, 'square', 0.1, 0.3);
            }

            playWhoosh() {
                if(Math.random() > 0.5) return;
                this.playNoise(0.1, 0.05);
            }

            playWin() {
                this.stop(); // Stop BGM
                // Simple Arpeggio
                [523, 659, 784, 1046, 523, 659, 784, 1046].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 'square', 0.2, 0.2), i * 150);
                });
            }

            playLose() {
                this.stop();
                this.playTone(150, 'sawtooth', 1.0, 0.3);
            }
        }

        const soundManager = new SoundManager();

        // --- å…¨åŸŸè®Šæ•¸ ---
        let camera, scene, renderer;
        let moveForward = false, moveBackward = false, rotateLeft = false, rotateRight = false;

        const PLAYER_SPEED = 250.0;
        const ROTATE_SPEED = 2.0;
        
        let prevTime = performance.now();
        const TILE_SIZE = 25;
        const WALL_HEIGHT = 20;
        const MAZE_SIZE = 15;
        let maze = [];
        let exitPosition = new THREE.Vector3();
        let gameActive = false;
        let timeLeft = 120;
        let timerInterval;
        
        // å‹•ç‰©åˆ—è¡¨
        let animals = [];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 150);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.y = 8;
            camera.rotation.order = 'YXZ'; 

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);

            const startBtn = document.getElementById('start-btn');
            const blocker = document.getElementById('blocker');

            startBtn.addEventListener('click', function() {
                blocker.style.display = 'none';
                gameActive = true;
                prevTime = performance.now();
                soundManager.init();
                startTimer();
            });

            // éµç›¤æ§åˆ¶
            const onKeyDown = (e) => {
                const k = e.key.toLowerCase(), c = e.code;
                if(c==='ArrowUp'||c==='KeyW'||k==='w') { moveForward=true; document.getElementById('key-w').classList.add('key-active'); }
                if(c==='ArrowDown'||c==='KeyS'||k==='s') { moveBackward=true; document.getElementById('key-s').classList.add('key-active'); }
                if(c==='ArrowLeft'||c==='KeyA'||k==='a') { rotateLeft=true; document.getElementById('key-a').classList.add('key-active'); }
                if(c==='ArrowRight'||c==='KeyD'||k==='d') { rotateRight=true; document.getElementById('key-d').classList.add('key-active'); }
            };
            const onKeyUp = (e) => {
                const k = e.key.toLowerCase(), c = e.code;
                if(c==='ArrowUp'||c==='KeyW'||k==='w') { moveForward=false; document.getElementById('key-w').classList.remove('key-active'); }
                if(c==='ArrowDown'||c==='KeyS'||k==='s') { moveBackward=false; document.getElementById('key-s').classList.remove('key-active'); }
                if(c==='ArrowLeft'||c==='KeyA'||k==='a') { rotateLeft=false; document.getElementById('key-a').classList.remove('key-active'); }
                if(c==='ArrowRight'||c==='KeyD'||k==='d') { rotateRight=false; document.getElementById('key-d').classList.remove('key-active'); }
            };
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            createMazeWorld();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);
        }

        // --- Low Poly å‹•ç‰©ç”Ÿæˆ ---
        function createRabbit(x, z) {
            const group = new THREE.Group();
            
            // èº«é«”
            const bodyGeo = new THREE.BoxGeometry(2, 1.5, 3);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff }); // ç™½å…”
            const body = new THREE.Mesh(bodyGeo, mat);
            body.position.y = 0.75;
            
            // é ­
            const headGeo = new THREE.BoxGeometry(1.5, 1.5, 2);
            const head = new THREE.Mesh(headGeo, mat);
            head.position.set(0, 2, 1.2);
            
            // è€³æœµ
            const earGeo = new THREE.BoxGeometry(0.4, 2, 0.4);
            const earMat = new THREE.MeshStandardMaterial({ color: 0xffcccc }); // ç²‰ç´…è€³
            const earL = new THREE.Mesh(earGeo, earMat);
            earL.position.set(-0.5, 3.5, 1);
            const earR = new THREE.Mesh(earGeo, earMat);
            earR.position.set(0.5, 3.5, 1);

            group.add(body, head, earL, earR);
            group.position.set(x, 0, z);
            group.castShadow = true;
            
            scene.add(group);

            return {
                mesh: group,
                type: 'rabbit',
                baseY: 0,
                hopOffset: Math.random() * 10,
                speed: 0.05 + Math.random() * 0.05,
                rotSpeed: (Math.random() - 0.5) * 0.02
            };
        }

        function createBird(x, z, y) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xffd700 }); // é‡‘çµ²é›€
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 2), mat);
            const wingL = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 1), mat);
            wingL.position.x = -1.5;
            const wingR = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 1), mat);
            wingR.position.x = 1.5;

            group.add(body, wingL, wingR);
            group.position.set(x, y, z);
            scene.add(group);

            return {
                mesh: group,
                type: 'bird',
                baseY: y,
                circleCenter: { x: x, z: z },
                angle: Math.random() * Math.PI * 2,
                radius: 10 + Math.random() * 20,
                speed: 1 + Math.random()
            };
        }

        function updateAnimals(time) {
            animals.forEach(animal => {
                if (animal.type === 'rabbit') {
                    // è·³èºå‹•ç•«
                    const hopHeight = Math.abs(Math.sin(time * 5 + animal.hopOffset)) * 2;
                    animal.mesh.position.y = animal.baseY + hopHeight;
                    // ç·©æ…¢æ—‹è½‰
                    animal.mesh.rotation.y += animal.rotSpeed;
                } else if (animal.type === 'bird') {
                    // ç›¤æ—‹å‹•ç•«
                    animal.angle += 0.01 * animal.speed;
                    animal.mesh.position.x = animal.circleCenter.x + Math.cos(animal.angle) * animal.radius;
                    animal.mesh.position.z = animal.circleCenter.z + Math.sin(animal.angle) * animal.radius;
                    animal.mesh.position.y = animal.baseY + Math.sin(time * 2) * 0.5; // ä¸Šä¸‹æµ®å‹•
                    animal.mesh.lookAt(
                        animal.circleCenter.x + Math.cos(animal.angle + 0.1) * animal.radius,
                        animal.mesh.position.y,
                        animal.circleCenter.z + Math.sin(animal.angle + 0.1) * animal.radius
                    );
                }
            });
        }

        // --- è¿·å®®ç”Ÿæˆ ---
        function createBuildingTexture(colorHex) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = colorHex; ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(10,10,15,25); ctx.fillRect(39,10,15,25);
            ctx.fillRect(10,40,15,10); ctx.fillRect(39,40,15,10);
            return new THREE.CanvasTexture(canvas);
        }

        function createMazeWorld() {
            maze = Array(MAZE_SIZE).fill().map(() => Array(MAZE_SIZE).fill(1));
            function carve(x, y) {
                const dirs = [[1,0], [-1,0], [0,1], [0,-1]].sort(() => Math.random()-0.5);
                dirs.forEach(([dx, dy]) => {
                    const nx = x + dx*2, ny = y + dy*2;
                    if (nx > 0 && nx < MAZE_SIZE-1 && ny > 0 && ny < MAZE_SIZE-1 && maze[ny][nx] === 1) {
                        maze[y+dy][x+dx] = 0;
                        maze[ny][nx] = 0;
                        carve(nx, ny);
                    }
                });
            }
            maze[1][1] = 0; carve(1,1);

            const floorMat = new THREE.MeshStandardMaterial({ color: 0x55aa55 });
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), floorMat);
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            scene.add(floor);

            const boxGeo = new THREE.BoxGeometry(TILE_SIZE, WALL_HEIGHT, TILE_SIZE);
            const wallMat1 = new THREE.MeshStandardMaterial({ color: 0xcccccc, map: createBuildingTexture('#aaaaaa') });
            const wallMat2 = new THREE.MeshStandardMaterial({ color: 0xd35400, map: createBuildingTexture('#c0392b') });

            const trunkGeo = new THREE.CylinderGeometry(1,1,4,6);
            const leavesGeo = new THREE.ConeGeometry(4,10,8);
            const trunkMat = new THREE.MeshStandardMaterial({color:0x5D4037});
            const leavesMat = new THREE.MeshStandardMaterial({color:0x228B22});

            for(let y=0; y<MAZE_SIZE; y++){
                for(let x=0; x<MAZE_SIZE; x++){
                    const px = (x - MAZE_SIZE/2) * TILE_SIZE;
                    const pz = (y - MAZE_SIZE/2) * TILE_SIZE;
                    if(maze[y][x] === 1) {
                        const wall = new THREE.Mesh(boxGeo, Math.random()>0.5 ? wallMat1 : wallMat2);
                        wall.position.set(px, WALL_HEIGHT/2, pz);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                    } else {
                        // ç©ºåœ°ï¼šéš¨æ©Ÿç”Ÿæˆæ¨¹æˆ–å‹•ç‰©
                        const rand = Math.random();
                        if(rand > 0.90) { // 10% æ©Ÿç‡ç¨®æ¨¹
                             const grp = new THREE.Group();
                             const t = new THREE.Mesh(trunkGeo, trunkMat); t.position.y=2;
                             const l = new THREE.Mesh(leavesGeo, leavesMat); l.position.y=8;
                             grp.add(t); grp.add(l);
                             grp.position.set(px + (Math.random()-0.5)*10, 0, pz + (Math.random()-0.5)*10);
                             scene.add(grp);
                        } else if (rand > 0.85) { // 5% æ©Ÿç‡ç”Ÿæˆå…”å­
                            animals.push(createRabbit(px, pz));
                        }
                    }
                }
            }

            // æ·»åŠ å¹¾éš»é£›é³¥
            for(let i=0; i<5; i++) {
                animals.push(createBird(0, 0, 30 + Math.random() * 20));
            }

            maze[1][1] = 0; 
            camera.position.set((1 - MAZE_SIZE / 2) * TILE_SIZE, 8, (1 - MAZE_SIZE / 2) * TILE_SIZE);
            camera.rotation.y = Math.PI; 

            let ex = MAZE_SIZE-2, ey = MAZE_SIZE-2;
            if(maze[ey][ex]===1) { ex=1; ey=MAZE_SIZE-2; }
            exitPosition.set((ex-MAZE_SIZE/2)*TILE_SIZE, 0, (ey-MAZE_SIZE/2)*TILE_SIZE);

            const exitMark = new THREE.Mesh(new THREE.CylinderGeometry(1,1,100,8), new THREE.MeshBasicMaterial({color:0x00ff00, transparent:true, opacity:0.5}));
            exitMark.position.copy(exitPosition); exitMark.position.y=50;
            scene.add(exitMark);
        }

        function startTimer() {
            clearInterval(timerInterval);
            const display = document.getElementById('time-display');
            timerInterval = setInterval(() => {
                if(!gameActive) return;
                timeLeft--;
                display.textContent = `æ™‚é–“: ${Math.floor(timeLeft/60).toString().padStart(2,'0')}:${(timeLeft%60).toString().padStart(2,'0')}`;
                if(timeLeft<=0) gameOver(false);
            }, 1000);
        }

        function checkWinCondition() {
            const pos = camera.position;
            const dist = Math.hypot(pos.x - exitPosition.x, pos.z - exitPosition.z);
            if(dist < 10) gameOver(true);
        }

        function gameOver(win) {
            gameActive = false;
            clearInterval(timerInterval);
            document.getElementById('result-screen').style.display = 'flex';
            document.getElementById('result-message').innerText = win ? "ä»»å‹™å®Œæˆï¼" : "æ™‚é–“åˆ°ï¼";
            document.getElementById('result-message').className = win ? "win-text" : "lose-text";
            if (win) soundManager.playWin(); else soundManager.playLose();
        }

        function checkCollision(pos) {
            const pX = pos.x;
            const pZ = pos.z;
            const r = 1.5; 
            const checks = [{x:pX+r, z:pZ}, {x:pX-r, z:pZ}, {x:pX, z:pZ+r}, {x:pX, z:pZ-r}];
            for (let p of checks) {
                const gx = Math.round((p.x / TILE_SIZE) + (MAZE_SIZE / 2));
                const gy = Math.round((p.z / TILE_SIZE) + (MAZE_SIZE / 2));
                if (gx >= 0 && gx < MAZE_SIZE && gy >= 0 && gy < MAZE_SIZE) {
                    if (maze[gy][gx] === 1) return true;
                }
            }
            return false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); 
            prevTime = time;

            if (gameActive) {
                // å‹•ç‰©æ›´æ–°
                updateAnimals(time / 1000);

                // ç©å®¶æ§åˆ¶
                if (rotateLeft) { camera.rotation.y += ROTATE_SPEED * delta; soundManager.playWhoosh(); }
                if (rotateRight) { camera.rotation.y -= ROTATE_SPEED * delta; soundManager.playWhoosh(); }

                let moveSpeed = 0;
                if (moveForward) moveSpeed = PLAYER_SPEED * delta;
                if (moveBackward) moveSpeed = -PLAYER_SPEED * delta;

                if (moveSpeed !== 0) {
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    forward.y = 0; forward.normalize();
                    const currentPos = camera.position.clone();
                    const nextX = currentPos.x + forward.x * moveSpeed;
                    const nextZ = currentPos.z + forward.z * moveSpeed;

                    let hitWall = false;
                    if (!checkCollision(new THREE.Vector3(nextX, currentPos.y, currentPos.z))) camera.position.x = nextX; else hitWall = true;
                    if (!checkCollision(new THREE.Vector3(camera.position.x, currentPos.y, nextZ))) camera.position.z = nextZ; else hitWall = true;

                    if (hitWall) soundManager.playCollision(); else soundManager.playFootstep();
                }
                checkWinCondition();
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
