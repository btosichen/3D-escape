<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ê†°ÂúíËø∑ÂÆÆÈÄÉËÑ´ (10ÈóúÊåëÊà∞Áâà)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #87CEEB;
            user-select: none;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            text-shadow: 2px 2px 4px #000;
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
        }
        #level-info {
            color: #f1c40f;
            margin-right: 20px;
        }
        
        #input-debug {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            pointer-events: none;
            opacity: 0.8;
        }
        .key-row { display: flex; gap: 5px; }
        .key-icon {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #fff;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 8px;
            font-family: monospace;
            font-size: 20px;
            transition: all 0.1s;
        }
        .key-active {
            background: #e67e22;
            transform: scale(0.9);
            box-shadow: 0 0 10px #e67e22;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }
        #instructions {
            width: 500px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            text-align: center;
            color: #333;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 4px solid #3498db;
        }
        h1 { margin: 0 0 15px 0; color: #2c3e50; font-size: 36px; }
        p { font-size: 18px; margin: 8px 0; color: #555; }
        .key { background: #eee; color: #333; padding: 4px 10px; border: 1px solid #ccc; border-radius: 5px; font-weight: bold; }
        
        #start-btn {
            background: #2ecc71;
            color: white;
            font-size: 28px;
            padding: 15px 50px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 5px 0 #27ae60;
            transition: transform 0.1s;
            font-weight: bold;
        }
        #start-btn:active { transform: translateY(4px); box-shadow: 0 1px 0 #27ae60; }

        #result-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            z-index: 20;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            pointer-events: auto;
        }
        button.action-btn {
            padding: 15px 40px;
            font-size: 24px;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        .btn-next { background: #3498db; }
        .btn-retry { background: #e74c3c; }
        .btn-next:hover { background: #2980b9; }
        .btn-retry:hover { background: #c0392b; }
        
        .win-text { color: #2ecc71; font-size: 50px; text-shadow: 0 0 20px rgba(46, 204, 113, 0.5); font-weight: 800; }
        .lose-text { color: #e74c3c; font-size: 50px; text-shadow: 0 0 20px rgba(231, 76, 60, 0.5); font-weight: 800; }
        .level-complete-text { color: #f1c40f; font-size: 40px; margin-bottom: 10px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="hud">
            <div>
                <span id="level-info">Level 1 / 10</span>
                <span id="time-display">ÊôÇÈñì: 02:00</span>
            </div>
            <div id="status">Â∞ãÊâæÁ∂†Ëâ≤ÂÖâÊü±</div>
        </div>
        <div id="input-debug">
            <div class="key-row">
                <div id="key-w" class="key-icon">W</div>
            </div>
            <div class="key-row">
                <div id="key-a" class="key-icon">A</div>
                <div id="key-s" class="key-icon">S</div>
                <div id="key-d" class="key-icon">D</div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="blocker">
        <div id="instructions">
            <h1 id="menu-title">Ê†°ÂúíËø∑ÂÆÆÈÄÉËÑ´</h1>
            <p id="menu-subtitle">ÊåëÊà∞ 10 ÂÄãË∂ä‰æÜË∂äÈõ£ÁöÑÈóúÂç°ÔºÅ</p>
            <hr style="margin: 15px 0;">
            <p><span class="key">W</span> ÂâçÈÄ≤ &nbsp;&nbsp; <span class="key">S</span> ÂæåÈÄÄ</p>
            <p><span class="key">A</span> Â∑¶ËΩâ &nbsp;&nbsp; <span class="key">D</span> Âè≥ËΩâ</p>
            <br>
            <button id="start-btn">ÈñãÂßãÁ¨¨ 1 Èóú</button>
            <p style="font-size: 14px; margin-top: 15px; color: #e74c3c;">‚ö†Ô∏è Ë´ãÁ¢∫Ë™çËº∏ÂÖ•Ê≥ïÁÇ∫Ëã±Êñá</p>
        </div>
    </div>

    <div id="result-screen">
        <div id="result-title" class="win-text"></div>
        <p id="result-message" style="font-size: 24px; margin: 20px; color: #ddd;"></p>
        <button id="action-btn" class="action-btn" onclick="handleAction()">‰∏ã‰∏ÄÈóú</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- ÈóúÂç°Ë®≠ÂÆö ---
        // mazeSize ÂøÖÈ†àÊòØÂ•áÊï∏
        const LEVELS = [
            { id: 1, size: 15, time: 60, desc: "ÊöñË∫´ÈÅãÂãï" },
            { id: 2, size: 17, time: 90, desc: "Á®çÂæÆËÆäÂ§ß‰∫Ü" },
            { id: 3, size: 19, time: 100, desc: "‰∏çË¶ÅËø∑Ë∑Ø" },
            { id: 4, size: 21, time: 120, desc: "Ê†°ÂúíÊé¢Èö™" },
            { id: 5, size: 23, time: 130, desc: "ÊôÇÈñìÁ∑äËø´" },
            { id: 6, size: 25, time: 150, desc: "‰∏≠Á¥öÊåëÊà∞" },
            { id: 7, size: 27, time: 160, desc: "ÈåØÁ∂úË§áÈõú" },
            { id: 8, size: 29, time: 180, desc: "Ëø∑ÂÆÆÂ§ßÂ∏´" },
            { id: 9, size: 31, time: 200, desc: "Ê•µÈôêÈÇäÁ∑£" },
            { id: 10, size: 33, time: 220, desc: "ÊúÄÁµÇË©¶ÁÖâ" }
        ];

        let currentLevelIndex = 0; // 0-based index
        let currentLevelData = LEVELS[0];

        // --- Èü≥ÊïàÁÆ°ÁêÜÂô® ---
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.nextStepTime = 0;
                this.bgmTimer = null;
                this.bgmNoteIndex = 0;
                this.isPlaying = false;
            }

            init() {
                if(!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                }
                if(this.ctx.state === 'suspended') this.ctx.resume();
                
                this.startAmbience();
                this.startBGM();
                this.isPlaying = true;
            }

            stop() {
                this.isPlaying = false;
                if (this.bgmTimer) clearTimeout(this.bgmTimer);
                // ‰∏çÈóúÈñâ contextÔºåÂè™ÂÅúÊ≠¢Êí≠ÊîæÈÇèËºØÔºå‰ª•‰æø‰∏ã‰∏ÄÈóúÈáçÁî®
            }

            startBGM() {
                if (!this.ctx || !this.isPlaying) return;
                
                const bassLine = [110, 110, 146, 110, 130, 110, 98, 110];
                const leadLine = [440, 0, 523, 440, 587, 0, 659, 587];
                // Èö®ÈóúÂç°Âä†Âø´ÁØÄÂ•è
                const baseTempo = 250; 
                const tempo = Math.max(150, baseTempo - (currentLevelIndex * 10));

                const playStep = () => {
                    if (!this.isPlaying) return;

                    const idx = this.bgmNoteIndex % 8;
                    if (bassLine[idx] > 0) this.playTone(bassLine[idx], 'sawtooth', 0.1, 0.05);
                    if (leadLine[idx] > 0 && Math.random() > 0.3) {
                        this.playTone(leadLine[idx], 'square', 0.1, 0.03);
                        setTimeout(() => this.playTone(leadLine[idx], 'sine', 0.1, 0.01), 150);
                    }
                    if (idx % 2 === 0) this.playNoise(0.03, 0.02);

                    this.bgmNoteIndex++;
                    this.bgmTimer = setTimeout(playStep, tempo);
                };
                playStep();
            }

            playTone(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playNoise(duration, vol) {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 5000;
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                noise.start();
            }

            startAmbience() {
                // Á∞°ÂñÆÈ¢®ËÅ≤
                // (ÁúÅÁï•ÈÉ®ÂàÜ‰ª•ÁØÄÁúÅÈï∑Â∫¶ÔºåËàáÂâçÁâàÁõ∏ÂêåÈÇèËºØ)
            }

            playFootstep() {
                if (!this.ctx || this.ctx.currentTime < this.nextStepTime) return;
                this.playTone(100, 'triangle', 0.05, 0.2);
                this.nextStepTime = this.ctx.currentTime + 0.35;
            }
            playCollision() { this.playTone(60, 'square', 0.1, 0.3); }
            playWhoosh() { if(Math.random()>0.5) this.playNoise(0.1, 0.05); }
            
            playWin() {
                this.stop();
                [523, 659, 784, 1046, 523, 659, 784, 1046].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 'square', 0.2, 0.2), i * 150);
                });
            }
            playLose() {
                this.stop();
                this.playTone(150, 'sawtooth', 1.0, 0.3);
                setTimeout(() => this.playTone(100, 'sawtooth', 1.5, 0.3), 400);
            }
        }

        const soundManager = new SoundManager();

        // --- ÂÖ®ÂüüËÆäÊï∏ ---
        let camera, scene, renderer;
        let moveForward = false, moveBackward = false, rotateLeft = false, rotateRight = false;
        
        // Â†¥ÊôØÁâ©‰ª∂Áæ§ÁµÑ (Êñπ‰æøÊ∏ÖÈô§)
        let worldGroup = new THREE.Group();

        const PLAYER_SPEED = 250.0;
        const ROTATE_SPEED = 2.0;
        
        let prevTime = performance.now();
        const TILE_SIZE = 25;
        const WALL_HEIGHT = 20;
        
        // ÈÅäÊà≤ÁãÄÊÖã
        let maze = [];
        let exitPosition = new THREE.Vector3();
        let gameActive = false;
        let timeLeft = 0;
        let timerInterval;
        let animals = [];

        // Êö¥Èú≤Áµ¶ HTML ÊåâÈàïÁî®
        window.handleAction = function() {
            const btn = document.getElementById('action-btn');
            const resultScreen = document.getElementById('result-screen');
            
            if (btn.classList.contains('btn-next')) {
                // ‰∏ã‰∏ÄÈóú
                currentLevelIndex++;
                if (currentLevelIndex >= LEVELS.length) {
                    // ÂÖ®Á†¥Èáç‰æÜ
                    currentLevelIndex = 0;
                    document.getElementById('menu-title').innerText = "Ê†°ÂúíËø∑ÂÆÆÈÄÉËÑ´";
                    document.getElementById('start-btn').innerText = "ÈñãÂßãÁ¨¨ 1 Èóú";
                    document.getElementById('blocker').style.display = 'flex';
                    resultScreen.style.display = 'none';
                } else {
                    // ÈÄ≤ÂÖ•‰∏ã‰∏ÄÈóú
                    resultScreen.style.display = 'none';
                    startLevel(currentLevelIndex);
                }
            } else {
                // ÈáçË©¶
                resultScreen.style.display = 'none';
                startLevel(currentLevelIndex);
            }
        };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.rotation.order = 'YXZ'; 

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            // ÂÑ™ÂåñÈô∞ÂΩ±ÁØÑÂúç‰ª•ÈÅ©ÊáâÂ§ßËø∑ÂÆÆ
            sunLight.shadow.camera.left = -200;
            sunLight.shadow.camera.right = 200;
            sunLight.shadow.camera.top = 200;
            sunLight.shadow.camera.bottom = -200;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            scene.add(worldGroup);

            const startBtn = document.getElementById('start-btn');
            startBtn.addEventListener('click', function() {
                document.getElementById('blocker').style.display = 'none';
                soundManager.init();
                startLevel(0); // ÂæûÁ¨¨ 0 Èóú (Level 1) ÈñãÂßã
            });

            // Input handlers
            const onKeyDown = (e) => {
                const k = e.key.toLowerCase(), c = e.code;
                if(c==='ArrowUp'||c==='KeyW'||k==='w') { moveForward=true; document.getElementById('key-w').classList.add('key-active'); }
                if(c==='ArrowDown'||c==='KeyS'||k==='s') { moveBackward=true; document.getElementById('key-s').classList.add('key-active'); }
                if(c==='ArrowLeft'||c==='KeyA'||k==='a') { rotateLeft=true; document.getElementById('key-a').classList.add('key-active'); }
                if(c==='ArrowRight'||c==='KeyD'||k==='d') { rotateRight=true; document.getElementById('key-d').classList.add('key-active'); }
            };
            const onKeyUp = (e) => {
                const k = e.key.toLowerCase(), c = e.code;
                if(c==='ArrowUp'||c==='KeyW'||k==='w') { moveForward=false; document.getElementById('key-w').classList.remove('key-active'); }
                if(c==='ArrowDown'||c==='KeyS'||k==='s') { moveBackward=false; document.getElementById('key-s').classList.remove('key-active'); }
                if(c==='ArrowLeft'||c==='KeyA'||k==='a') { rotateLeft=false; document.getElementById('key-a').classList.remove('key-active'); }
                if(c==='ArrowRight'||c==='KeyD'||k==='d') { rotateRight=false; document.getElementById('key-d').classList.remove('key-active'); }
            };
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);
        }

        // --- Ê†∏ÂøÉÔºöÈñãÂßãÁâπÂÆöÈóúÂç° ---
        function startLevel(index) {
            currentLevelIndex = index;
            currentLevelData = LEVELS[index];

            // 1. Ê∏ÖÁêÜËàäÂ†¥ÊôØ
            while(worldGroup.children.length > 0){ 
                const obj = worldGroup.children[0];
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) {
                    if(Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose());
                    else obj.material.dispose();
                }
                worldGroup.remove(obj); 
            }
            animals = [];

            // 2. Êõ¥Êñ∞ UI
            document.getElementById('level-info').innerText = `Level ${currentLevelData.id} / ${LEVELS.length}`;
            timeLeft = currentLevelData.time;
            updateTimeDisplay();

            // 3. ÁîüÊàêÊñ∞Ëø∑ÂÆÆ
            createMazeWorld(currentLevelData.size);

            // 4. ÈáçÁΩÆÁé©ÂÆ∂
            moveForward = false; moveBackward = false; rotateLeft = false; rotateRight = false;
            prevTime = performance.now();
            gameActive = true;
            soundManager.isPlaying = true;
            soundManager.startBGM();

            // 5. ÂïüÂãïË®àÊôÇÂô®
            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if(!gameActive) return;
                timeLeft--;
                updateTimeDisplay();
                if(timeLeft <= 0) gameOver(false);
            }, 1000);
        }

        function updateTimeDisplay() {
            const m = Math.floor(timeLeft/60).toString().padStart(2,'0');
            const s = (timeLeft%60).toString().padStart(2,'0');
            document.getElementById('time-display').innerText = `ÊôÇÈñì: ${m}:${s}`;
        }

        // --- ÂãïÁâ©ËàáËø∑ÂÆÆÁîüÊàê (Âê´Ê∏ÖÁêÜÈÇèËºØ) ---
        // (Ëàá‰πãÂâçÁâàÊú¨È°û‰ººÔºå‰ΩÜÁèæÂú®Áâ©‰ª∂Âä†ÂÖ• worldGroup ËÄåÈùû scene)

        function createRabbit(x, z) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 3), mat); body.position.y = 0.75;
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 2), mat); head.position.set(0, 2, 1.2);
            const earMat = new THREE.MeshStandardMaterial({ color: 0xffcccc });
            const earL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2, 0.4), earMat); earL.position.set(-0.5, 3.5, 1);
            const earR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2, 0.4), earMat); earR.position.set(0.5, 3.5, 1);
            group.add(body, head, earL, earR);
            group.position.set(x, 0, z);
            group.castShadow = true;
            worldGroup.add(group); // Changed to worldGroup
            return { mesh: group, type: 'rabbit', baseY: 0, hopOffset: Math.random()*10, speed: 0.05, rotSpeed: (Math.random()-0.5)*0.02 };
        }

        function createBird(x, z, y) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xffd700 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 2), mat);
            const wL = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 1), mat); wL.position.x = -1.5;
            const wR = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 1), mat); wR.position.x = 1.5;
            group.add(body, wL, wR);
            group.position.set(x, y, z);
            worldGroup.add(group); // Changed to worldGroup
            return { mesh: group, type: 'bird', baseY: y, circleCenter: {x,z}, angle: Math.random()*6, radius: 10+Math.random()*20, speed: 1+Math.random() };
        }

        function createBuildingTexture(colorHex) {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = colorHex; ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#87CEEB'; ctx.fillRect(10,10,15,25); ctx.fillRect(39,10,15,25); ctx.fillRect(10,40,15,10); ctx.fillRect(39,40,15,10);
            return new THREE.CanvasTexture(canvas);
        }

        function createMazeWorld(mazeSize) {
            // ÁîüÊàêËø∑ÂÆÆË≥áÊñô
            maze = Array(mazeSize).fill().map(() => Array(mazeSize).fill(1));
            function carve(x, y) {
                const dirs = [[1,0], [-1,0], [0,1], [0,-1]].sort(() => Math.random()-0.5);
                dirs.forEach(([dx, dy]) => {
                    const nx = x + dx*2, ny = y + dy*2;
                    if (nx > 0 && nx < mazeSize-1 && ny > 0 && ny < mazeSize-1 && maze[ny][nx] === 1) {
                        maze[y+dy][x+dx] = 0; maze[ny][nx] = 0; carve(nx, ny);
                    }
                });
            }
            maze[1][1] = 0; carve(1,1);

            // Âú∞Êùø (Ê†πÊìöÈóúÂç°Â§ßÂ∞èÂãïÊÖãË™øÊï¥)
            const floorSize = mazeSize * TILE_SIZE * 1.5;
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x55aa55 });
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, floorSize), floorMat);
            floor.rotation.x = -Math.PI/2; floor.receiveShadow = true;
            worldGroup.add(floor);

            const boxGeo = new THREE.BoxGeometry(TILE_SIZE, WALL_HEIGHT, TILE_SIZE);
            const wallMat1 = new THREE.MeshStandardMaterial({ color: 0xcccccc, map: createBuildingTexture('#aaaaaa') });
            const wallMat2 = new THREE.MeshStandardMaterial({ color: 0xd35400, map: createBuildingTexture('#c0392b') });

            const trunkGeo = new THREE.CylinderGeometry(1,1,4,6);
            const leavesGeo = new THREE.ConeGeometry(4,10,8);
            const trunkMat = new THREE.MeshStandardMaterial({color:0x5D4037});
            const leavesMat = new THREE.MeshStandardMaterial({color:0x228B22});

            for(let y=0; y<mazeSize; y++){
                for(let x=0; x<mazeSize; x++){
                    const px = (x - mazeSize/2) * TILE_SIZE;
                    const pz = (y - mazeSize/2) * TILE_SIZE;
                    if(maze[y][x] === 1) {
                        const wall = new THREE.Mesh(boxGeo, Math.random()>0.5 ? wallMat1 : wallMat2);
                        wall.position.set(px, WALL_HEIGHT/2, pz);
                        wall.castShadow = true; wall.receiveShadow = true;
                        worldGroup.add(wall);
                    } else {
                        // Áâ©ÂìÅÁîüÊàêÊ©üÁéáÈö®Ëø∑ÂÆÆËÆäÂ§ßËÄåÈôç‰ΩéÔºåÈÅøÂÖçÁâ©‰ª∂ÈÅéÂ§ö
                        const density = Math.max(0.85, 0.95 - (currentLevelIndex * 0.01));
                        if(Math.random() > density) {
                            if(Math.random() > 0.3) { // Ê®π
                                const grp = new THREE.Group();
                                const t = new THREE.Mesh(trunkGeo, trunkMat); t.position.y=2;
                                const l = new THREE.Mesh(leavesGeo, leavesMat); l.position.y=8;
                                grp.add(t, l);
                                grp.position.set(px + (Math.random()-0.5)*10, 0, pz + (Math.random()-0.5)*10);
                                worldGroup.add(grp);
                            } else { // ÂÖîÂ≠ê
                                animals.push(createRabbit(px, pz));
                            }
                        }
                    }
                }
            }

            // È≥•
            for(let i=0; i<3 + currentLevelIndex; i++) {
                animals.push(createBird(0, 0, 30 + Math.random()*20));
            }

            // Ë®≠ÂÆöËµ∑ÈªûËàáÁµÇÈªû
            maze[1][1] = 0; 
            camera.position.set((1 - mazeSize / 2) * TILE_SIZE, 8, (1 - mazeSize / 2) * TILE_SIZE);
            camera.rotation.y = Math.PI;
            camera.rotation.x = 0; // ÈáçÁΩÆ‰øØ‰ª∞Ëßí

            let ex = mazeSize-2, ey = mazeSize-2;
            if(maze[ey][ex]===1) { ex=1; ey=mazeSize-2; }
            exitPosition.set((ex-mazeSize/2)*TILE_SIZE, 0, (ey-mazeSize/2)*TILE_SIZE);

            const exitMark = new THREE.Mesh(new THREE.CylinderGeometry(1,1,100,8), new THREE.MeshBasicMaterial({color:0x00ff00, transparent:true, opacity:0.5}));
            exitMark.position.copy(exitPosition); exitMark.position.y=50;
            worldGroup.add(exitMark);
        }

        function checkWinCondition() {
            const pos = camera.position;
            const dist = Math.hypot(pos.x - exitPosition.x, pos.z - exitPosition.z);
            if(dist < 10) gameOver(true);
        }

        function gameOver(win) {
            gameActive = false;
            clearInterval(timerInterval);
            const screen = document.getElementById('result-screen');
            const title = document.getElementById('result-title');
            const msg = document.getElementById('result-message');
            const btn = document.getElementById('action-btn');
            
            screen.style.display = 'flex';

            if (win) {
                soundManager.playWin();
                if (currentLevelIndex + 1 >= LEVELS.length) {
                    // ÂÖ®Á†¥
                    title.innerText = "üéâ ÊÅ≠ÂñúÈÄöÈóúÔºÅ üéâ";
                    title.className = "win-text";
                    msg.innerText = "‰Ω†Â∑≤ÂæÅÊúçÊâÄÊúâËø∑ÂÆÆÔºåÊàêÁÇ∫ÂÇ≥Ë™™‰∏≠ÁöÑÈÄÉËÑ´Â§ßÂ∏´ÔºÅ";
                    btn.innerText = "ÂõûÂà∞‰∏ªÈÅ∏ÂñÆ";
                    btn.className = "action-btn btn-next";
                    btn.onclick = () => location.reload();
                } else {
                    // ‰∏ã‰∏ÄÈóú
                    title.innerText = "ÈóúÂç°ÂÆåÊàêÔºÅ";
                    title.className = "level-complete-text";
                    msg.innerText = `Ê∫ñÂÇôÈÄ≤ÂÖ• Level ${currentLevelData.id + 1}`;
                    btn.innerText = "‰∏ã‰∏ÄÈóú >>";
                    btn.className = "action-btn btn-next";
                }
            } else {
                // Â§±Êïó
                soundManager.playLose();
                title.innerText = "ÊôÇÈñìÂà∞ÔºÅ";
                title.className = "lose-text";
                msg.innerText = "‰∏çË¶ÅÁÅ∞ÂøÉÔºåÂÜçË©¶‰∏ÄÊ¨°ÂêßÔºÅ";
                btn.innerText = "ÈáçË©¶Êú¨Èóú";
                btn.className = "action-btn btn-retry";
            }
        }

        // --- Áâ©ÁêÜËàáÂãïÁï´ ---
        function updateAnimals(dt) {
            const time = performance.now()/1000;
            animals.forEach(ani => {
                if(ani.type==='rabbit') {
                    ani.mesh.position.y = ani.baseY + Math.abs(Math.sin(time*5 + ani.hopOffset))*2;
                    ani.mesh.rotation.y += ani.rotSpeed;
                } else if(ani.type==='bird') {
                    ani.angle += 0.01 * ani.speed;
                    ani.mesh.position.x = ani.circleCenter.x + Math.cos(ani.angle)*ani.radius;
                    ani.mesh.position.z = ani.circleCenter.z + Math.sin(ani.angle)*ani.radius;
                    ani.mesh.lookAt(
                        ani.circleCenter.x+Math.cos(ani.angle+0.1)*ani.radius,
                        ani.mesh.position.y,
                        ani.circleCenter.z+Math.sin(ani.angle+0.1)*ani.radius
                    );
                }
            });
        }

        function checkCollision(pos) {
            const pX = pos.x; const pZ = pos.z; const r = 1.5; 
            const checks = [{x:pX+r, z:pZ}, {x:pX-r, z:pZ}, {x:pX, z:pZ+r}, {x:pX, z:pZ-r}];
            const ms = currentLevelData.size; // ‰ΩøÁî®Áï∂ÂâçÈóúÂç°Â§ßÂ∞è
            for (let p of checks) {
                const gx = Math.round((p.x / TILE_SIZE) + (ms / 2));
                const gy = Math.round((p.z / TILE_SIZE) + (ms / 2));
                if (gx >= 0 && gx < ms && gy >= 0 && gy < ms) {
                    if (maze[gy][gx] === 1) return true;
                }
            }
            return false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); 
            prevTime = time;

            if (gameActive) {
                updateAnimals(delta);

                if (rotateLeft) { camera.rotation.y += ROTATE_SPEED * delta; soundManager.playWhoosh(); }
                if (rotateRight) { camera.rotation.y -= ROTATE_SPEED * delta; soundManager.playWhoosh(); }

                let moveSpeed = 0;
                if (moveForward) moveSpeed = PLAYER_SPEED * delta;
                if (moveBackward) moveSpeed = -PLAYER_SPEED * delta;

                if (moveSpeed !== 0) {
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    forward.y = 0; forward.normalize();
                    const currentPos = camera.position.clone();
                    const nextX = currentPos.x + forward.x * moveSpeed;
                    const nextZ = currentPos.z + forward.z * moveSpeed;

                    let hitWall = false;
                    if (!checkCollision(new THREE.Vector3(nextX, currentPos.y, currentPos.z))) camera.position.x = nextX; else hitWall = true;
                    if (!checkCollision(new THREE.Vector3(camera.position.x, currentPos.y, nextZ))) camera.position.z = nextZ; else hitWall = true;

                    if (hitWall) soundManager.playCollision(); else soundManager.playFootstep();
                }
                checkWinCondition();
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
